<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clash Local Building Studio</title>
    <style>
      :root {
        --bg: #edf2fa;
        --panel: #ffffff;
        --line: #c6d1e6;
        --text: #1a2942;
        --muted: #536685;
        --accent: #2964ff;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        height: 100%;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        color: var(--text);
        background: var(--bg);
      }

      .app {
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 16px;
        padding: 14px 16px;
        border-bottom: 1px solid var(--line);
        background: #f8fbff;
      }

      .header h1 {
        margin: 0;
        font-size: 22px;
        line-height: 1.1;
      }

      .header p {
        margin: 6px 0 0;
        font-size: 13px;
        color: var(--muted);
      }

      .header-right {
        display: flex;
        align-items: center;
        gap: 14px;
        flex-wrap: wrap;
      }

      .inline {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
      }

      .workspace {
        flex: 1;
        min-height: 0;
        display: grid;
        grid-template-columns: minmax(560px, 1fr) 400px;
        gap: 12px;
        padding: 12px 16px 16px;
      }

      .canvas-wrap {
        border: 1px solid var(--line);
        border-radius: 12px;
        overflow: hidden;
        background: #ffffff;
        min-height: 0;
      }

      .canvas-wrap > canvas {
        width: 100%;
        height: 100%;
        min-height: 590px;
        display: block;
        touch-action: none;
      }

      .panel {
        min-height: 0;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding-right: 2px;
      }

      .block {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: var(--panel);
        padding: 8px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .block h2 {
        margin: 0;
        font-size: 14px;
      }

      .small {
        font-size: 11px;
        color: var(--muted);
      }

      .stat {
        font-size: 11px;
        color: #223450;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 3px;
        font-size: 11px;
        color: #253653;
      }

      input,
      select,
      textarea,
      button {
        font: inherit;
      }

      input,
      select,
      textarea {
        border: 1px solid #9eb0cf;
        border-radius: 8px;
        padding: 5px 7px;
        background: #fff;
        color: #172743;
      }

      textarea {
        min-height: 130px;
        resize: vertical;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace;
        font-size: 11px;
      }

      button {
        border: 1px solid #8ca2cb;
        border-radius: 8px;
        background: #ffffff;
        color: #1e2f4b;
        padding: 5px 8px;
        font-size: 12px;
        line-height: 1.2;
        cursor: pointer;
      }

      .grid2 {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .level-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        max-height: 54px;
        overflow: auto;
      }

      .level-buttons button {
        padding: 4px 8px;
        min-width: 42px;
        border-radius: 7px;
      }

      .level-buttons button.active {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }

      .frame-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-height: 230px;
        overflow: auto;
      }

      .frame-row {
        border: 1px solid #cfd9ec;
        border-radius: 8px;
        padding: 4px;
        display: grid;
        grid-template-columns: minmax(0, 1fr) 72px auto auto auto;
        gap: 4px;
        align-items: center;
      }

      .frame-label {
        font-size: 12px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .frame-row input {
        width: 100%;
      }

      .spritesheet-editor {
        border: 1px solid #9eb0cf;
        border-radius: 8px;
        background: #10192b;
        overflow: hidden;
      }

      #spritesheet-canvas {
        width: 100%;
        height: 220px;
        display: block;
        touch-action: none;
        background:
          linear-gradient(45deg, rgba(255,255,255,0.04) 25%, transparent 25%),
          linear-gradient(-45deg, rgba(255,255,255,0.04) 25%, transparent 25%),
          linear-gradient(45deg, transparent 75%, rgba(255,255,255,0.04) 75%),
          linear-gradient(-45deg, transparent 75%, rgba(255,255,255,0.04) 75%),
          #0f1626;
        background-size: 18px 18px;
        background-position: 0 0, 0 9px, 9px -9px, -9px 0;
      }

      .sheet-hint {
        font-size: 11px;
        color: #4f6488;
      }

      .dropdown {
        display: block;
      }

      .dropdown > summary {
        list-style: none;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        color: #1a2942;
        user-select: none;
      }

      .dropdown > summary::-webkit-details-marker {
        display: none;
      }

      .dropdown > summary::after {
        content: '▸';
        float: right;
        color: #3b5688;
      }

      .dropdown[open] > summary::after {
        content: '▾';
      }

      .dropdown-content {
        margin-top: 6px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      @media (max-width: 1200px) {
        .workspace {
          grid-template-columns: 1fr;
        }

        .canvas-wrap > canvas {
          min-height: 470px;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="header">
        <div>
          <h1>Clash Local Building Studio</h1>
          <p>
            Standalone file. No localhost. Drag blue footprint to move like game placement, drag image to align art.
          </p>
        </div>
        <div class="header-right">
          <label class="inline">
            <input id="pixel-preview" type="checkbox" checked />
            Pixel Preview (fixed game value: 4)
          </label>
        </div>
      </div>

      <div class="workspace">
        <div class="canvas-wrap">
          <canvas id="studio-canvas"></canvas>
        </div>

        <div class="panel">
          <div class="block">
            <h2>Building</h2>
            <label>Building ID <input id="building-id" value="custom_watchtower" /></label>
            <label>Building Name <input id="building-name" value="Custom Watchtower" /></label>
            <div class="grid2">
              <label>Category
                <select id="building-category">
                  <option value="defense">defense</option>
                  <option value="resource">resource</option>
                  <option value="military">military</option>
                  <option value="other">other</option>
                </select>
              </label>
              <label>Cost <input id="building-cost" type="number" value="600" /></label>
              <label>Max Count <input id="building-max-count" type="number" value="3" /></label>
              <label>Map Size <input id="map-size" type="number" value="25" min="8" max="64" /></label>
              <label>Footprint Width <input id="footprint-width" type="number" value="2" min="1" max="10" /></label>
              <label>Footprint Height <input id="footprint-height" type="number" value="2" min="1" max="10" /></label>
            </div>
            <div class="stat" id="footprint-stat"></div>
          </div>

          <div class="block">
            <h2>Placement</h2>
            <div class="small">Blue outline only. Drag it on map, or set X/Y directly.</div>
            <div class="grid2">
              <label>Tile X <input id="place-x" type="number" value="10" /></label>
              <label>Tile Y <input id="place-y" type="number" value="10" /></label>
            </div>
            <div class="row">
              <button id="place-center" type="button">Center</button>
            </div>
          </div>

          <div class="block">
            <h2>Asset</h2>
            <div class="grid2">
              <label class="inline">
                <input id="ground-plane-enabled" type="checkbox" />
                Ground Plane Enabled
              </label>
              <label>Ground Plane Color
                <input id="ground-plane-color" type="color" value="#4a9c3d" />
              </label>
            </div>
          </div>

          <div class="block">
            <h2>Levels + Upgrade Sim</h2>
            <div class="small">Use level buttons and sidebar controls to simulate upgrades.</div>
            <div id="level-buttons" class="level-buttons"></div>
            <div class="row">
              <button id="level-add" type="button">Add Level</button>
              <button id="level-remove" type="button">Remove Last Level</button>
              <button id="level-clone" type="button">Clone Current To New</button>
            </div>
            <div class="row">
              <button id="level-up" type="button">Level Up</button>
              <button id="level-down" type="button">Level Down</button>
            </div>
            <div class="grid2">
              <label>Current Level <input id="current-level" type="number" value="1" min="1" /></label>
              <label>Upgrade Cost (current)
                <input id="upgrade-cost" type="number" value="500" min="0" />
              </label>
              <label>Sim Gold
                <input id="sim-gold" type="number" value="5000" min="0" />
              </label>
            </div>
            <div class="row">
              <button id="sim-add-gold" type="button">+5,000 Gold</button>
            </div>
            <div class="stat" id="level-stat"></div>
          </div>

          <div class="block">
            <h2>Animation Frames (Current Level)</h2>
            <label>Upload Frames (multiple)
              <input id="frame-upload" type="file" accept="image/*" multiple />
            </label>
            <label>Upload Sprite Sheet
              <input id="spritesheet-upload" type="file" accept="image/*" />
            </label>
            <div class="spritesheet-editor">
              <canvas id="spritesheet-canvas"></canvas>
            </div>
            <div class="sheet-hint" id="spritesheet-info">Load a sprite sheet, then drag the yellow box (corner resizes). Wheel zooms, drag outside box pans.</div>
            <div class="grid2">
              <label>Frame Width
                <input id="spritesheet-frame-width" type="number" min="1" value="64" />
              </label>
              <label>Frame Height
                <input id="spritesheet-frame-height" type="number" min="1" value="64" />
              </label>
              <label>Start X
                <input id="spritesheet-start-x" type="number" min="0" value="0" />
              </label>
              <label>Start Y
                <input id="spritesheet-start-y" type="number" min="0" value="0" />
              </label>
              <label>Spacing X
                <input id="spritesheet-spacing-x" type="number" min="0" value="0" />
              </label>
              <label>Spacing Y
                <input id="spritesheet-spacing-y" type="number" min="0" value="0" />
              </label>
              <label>Columns (0 = auto)
                <input id="spritesheet-cols" type="number" min="0" value="0" />
              </label>
              <label>Rows (0 = auto)
                <input id="spritesheet-rows" type="number" min="0" value="0" />
              </label>
              <label>Max Frames (0 = all)
                <input id="spritesheet-max-frames" type="number" min="0" value="0" />
              </label>
            </div>
            <div class="row">
              <button id="spritesheet-slice" type="button">Slice Sprite Sheet</button>
              <button id="spritesheet-reset-view" type="button">Reset View</button>
            </div>
            <div class="row">
              <button id="anim-play" type="button">Play</button>
              <button id="anim-stop" type="button">Stop</button>
              <button id="anim-reset" type="button">Reset Frame</button>
              <button id="frame-clear" type="button">Clear Frames</button>
            </div>
            <div class="grid2">
              <label>Default Frame ms
                <input id="frame-default-ms" type="number" min="16" value="160" />
              </label>
              <label class="inline"><input id="anim-loop" type="checkbox" checked /> Loop</label>
            </div>
            <div class="row">
              <button id="frame-apply-default" type="button">Apply Default ms To All</button>
            </div>
            <div class="stat" id="anim-stat"></div>
            <div id="frame-list" class="frame-list"></div>
          </div>

          <div class="block">
            <h2>Image Transform (Current Level)</h2>
            <div class="small">Image drag is always active when clicking image on canvas.</div>
            <label>Asset Label <input id="asset-label" value="tower_v1.png" /></label>
            <div class="grid2">
              <label>Offset X <input id="image-offset-x" type="number" value="0" /></label>
              <label>Offset Y <input id="image-offset-y" type="number" value="0" /></label>
              <label>Scale <input id="image-scale" type="number" step="0.05" value="1" /></label>
              <label>Rotation (deg) <input id="image-rotation" type="number" step="1" value="0" /></label>
              <label>Opacity <input id="image-opacity" type="number" step="0.05" min="0.05" max="1" value="1" /></label>
            </div>
            <div class="row">
              <button id="auto-fit" type="button">Auto Fit To Footprint</button>
              <button id="reset-image" type="button">Reset Transform</button>
            </div>
            <div class="small" id="image-info">No frames loaded for this level.</div>
          </div>

          <div class="block">
            <h2>Export</h2>
            <div class="row">
              <button id="copy-json" type="button">Copy JSON</button>
              <button id="download-json" type="button">Download JSON</button>
              <button id="copy-ts" type="button">Copy TS Snippet</button>
            </div>
            <label>JSON<textarea id="json-output" readonly></textarea></label>
            <label>TypeScript Snippet<textarea id="ts-output" readonly></textarea></label>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function () {
        'use strict';

        var TILE_W = 64;
        var TILE_H = 32;
        var HALF_W = TILE_W * 0.5;
        var HALF_H = TILE_H * 0.5;
        var PIXEL_SIZE_GAME_DEFAULT = 4;

        function clamp(v, min, max) {
          return Math.max(min, Math.min(max, v));
        }

        function clampInt(v, min, max) {
          return Math.floor(clamp(v, min, max));
        }

        function cartToIso(x, y) {
          return {
            x: (x - y) * HALF_W,
            y: (x + y) * HALF_H
          };
        }

        function isoToCart(isoX, isoY) {
          return {
            x: (isoX / HALF_W + isoY / HALF_H) * 0.5,
            y: (isoY / HALF_H - isoX / HALF_W) * 0.5
          };
        }

        function rgbToInt(r, g, b) {
          return (r << 16) | (g << 8) | b;
        }

        function intToRgb(hex) {
          return {
            r: (hex >> 16) & 0xff,
            g: (hex >> 8) & 0xff,
            b: hex & 0xff
          };
        }

        function rgbToStyle(hex, alpha) {
          var c = intToRgb(hex);
          return 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + alpha + ')';
        }

        function rgbToHsv(r, g, b) {
          var rr = r / 255;
          var gg = g / 255;
          var bb = b / 255;
          var max = Math.max(rr, gg, bb);
          var min = Math.min(rr, gg, bb);
          var delta = max - min;
          var h = 0;

          if (delta !== 0) {
            if (max === rr) h = ((gg - bb) / delta) % 6;
            else if (max === gg) h = (bb - rr) / delta + 2;
            else h = (rr - gg) / delta + 4;
            h /= 6;
            if (h < 0) h += 1;
          }

          var s = max === 0 ? 0 : delta / max;
          var v = max;
          return { h: h, s: s, v: v };
        }

        function hsvToRgb(h, s, v) {
          var i = Math.floor(h * 6);
          var f = h * 6 - i;
          var p = v * (1 - s);
          var q = v * (1 - f * s);
          var t = v * (1 - (1 - f) * s);
          var mod = i % 6;
          var r, g, b;

          if (mod === 0) { r = v; g = t; b = p; }
          else if (mod === 1) { r = q; g = v; b = p; }
          else if (mod === 2) { r = p; g = v; b = t; }
          else if (mod === 3) { r = p; g = q; b = v; }
          else if (mod === 4) { r = t; g = p; b = v; }
          else { r = v; g = p; b = q; }

          return {
            r: Math.round(clamp(r, 0, 1) * 255),
            g: Math.round(clamp(g, 0, 1) * 255),
            b: Math.round(clamp(b, 0, 1) * 255)
          };
        }

        function brightenHex(hex, amount) {
          var c = intToRgb(hex);
          var delta = Math.round(255 * (amount / 100));
          return rgbToInt(
            clampInt(c.r + delta, 0, 255),
            clampInt(c.g + delta, 0, 255),
            clampInt(c.b + delta, 0, 255)
          );
        }

        function darkenHex(hex, amount) {
          var c = intToRgb(hex);
          var hsv = rgbToHsv(c.r, c.g, c.b);
          hsv.v = clamp(hsv.v - amount / 100, 0, 1);
          var rgb = hsvToRgb(hsv.h, hsv.s, hsv.v);
          return rgbToInt(rgb.r, rgb.g, rgb.b);
        }

        function rotatePoint(x, y, deg) {
          var rad = (deg * Math.PI) / 180;
          var cos = Math.cos(rad);
          var sin = Math.sin(rad);
          return {
            x: x * cos - y * sin,
            y: x * sin + y * cos
          };
        }

        function hexToRgba(hex, alpha) {
          var h = String(hex || '').trim();
          if (/^#[0-9a-fA-F]{6}$/.test(h)) {
            var v = parseInt(h.slice(1), 16);
            var r = (v >> 16) & 255;
            var g = (v >> 8) & 255;
            var b = v & 255;
            return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';
          }
          return 'rgba(74,156,61,' + alpha + ')';
        }

        function getFrameOpaqueMetrics(frame) {
          if (!frame || !frame.image) {
            return null;
          }
          if (frame.opaqueMetrics) {
            return frame.opaqueMetrics;
          }

          var w = frame.width || frame.image.width || 0;
          var h = frame.height || frame.image.height || 0;
          if (w <= 0 || h <= 0) return null;

          var cv = document.createElement('canvas');
          cv.width = w;
          cv.height = h;
          var c = cv.getContext('2d');
          c.clearRect(0, 0, w, h);
          c.drawImage(frame.image, 0, 0, w, h);

          var data;
          try {
            data = c.getImageData(0, 0, w, h).data;
          } catch (_err) {
            // Fallback when pixel reads are unavailable.
            frame.opaqueMetrics = {
              lowestX: w * 0.5,
              lowestY: h,
              bounds: { minX: 0, minY: 0, maxX: w, maxY: h }
            };
            return frame.opaqueMetrics;
          }

          var minX = w;
          var minY = h;
          var maxX = 0;
          var maxY = 0;
          var lowestY = -1;
          var lowestMinX = w;
          var lowestMaxX = 0;
          var found = false;

          for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
              var a = data[(y * w + x) * 4 + 3];
              if (a <= 16) continue;
              found = true;
              if (x < minX) minX = x;
              if (y < minY) minY = y;
              if (x > maxX) maxX = x;
              if (y > maxY) maxY = y;

              if (y > lowestY) {
                lowestY = y;
                lowestMinX = x;
                lowestMaxX = x;
              } else if (y === lowestY) {
                if (x < lowestMinX) lowestMinX = x;
                if (x > lowestMaxX) lowestMaxX = x;
              }
            }
          }

          if (!found) {
            frame.opaqueMetrics = {
              lowestX: w * 0.5,
              lowestY: h,
              bounds: { minX: 0, minY: 0, maxX: w, maxY: h }
            };
            return frame.opaqueMetrics;
          }

          frame.opaqueMetrics = {
            lowestX: (lowestMinX + lowestMaxX) * 0.5,
            lowestY: lowestY,
            bounds: { minX: minX, minY: minY, maxX: maxX, maxY: maxY }
          };
          return frame.opaqueMetrics;
        }

        function makeLevel(level, source) {
          if (!source) {
            return {
              level: level,
              upgradeCost: 500,
              frames: [],
              frameIndex: 0,
              frameElapsed: 0,
              transform: {
                offsetX: 0,
                offsetY: 0,
                scale: 1,
                rotation: 0,
                opacity: 1
              }
            };
          }

          var clonedFrames = source.frames.map(function (f) {
            return {
              id: 'fr_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 7),
              label: f.label,
              durationMs: f.durationMs,
              image: f.image,
              width: f.width,
              height: f.height
            };
          });

          return {
            level: level,
            upgradeCost: source.upgradeCost,
            frames: clonedFrames,
            frameIndex: 0,
            frameElapsed: 0,
            transform: {
              offsetX: source.transform.offsetX,
              offsetY: source.transform.offsetY,
              scale: source.transform.scale,
              rotation: source.transform.rotation,
              opacity: source.transform.opacity
            }
          };
        }

        var state = {
          mapSize: 25,
          pixelPreview: true,
          building: {
            id: 'custom_watchtower',
            name: 'Custom Watchtower',
            category: 'defense',
            cost: 600,
            maxCount: 3,
            width: 2,
            height: 2,
            groundPlaneEnabled: false,
            groundPlaneColor: '#4a9c3d'
          },
          placement: {
            x: 10,
            y: 10,
            dragActive: false,
            dragStartTileX: 0,
            dragStartTileY: 0,
            startPlacementX: 0,
            startPlacementY: 0,
            pointerId: null
          },
          levels: [makeLevel(1)],
          currentLevel: 1,
          animation: {
            playing: true,
            loop: true,
            lastTs: 0,
            defaultDurationMs: 160
          },
          simulation: {
            gold: 5000,
            lastNotice: ''
          },
          sheetEditor: {
            image: null,
            fileName: '',
            width: 0,
            height: 0,
            viewScale: 1,
            viewOffsetX: 0,
            viewOffsetY: 0,
            dragActive: false,
            dragPointerId: null,
            dragMode: null,
            dragStartScreenX: 0,
            dragStartScreenY: 0,
            dragStartViewOffsetX: 0,
            dragStartViewOffsetY: 0,
            dragStartFrameX: 0,
            dragStartFrameY: 0,
            dragStartFrameW: 0,
            dragStartFrameH: 0
          },
          imageDrag: {
            active: false,
            pointerId: null,
            offsetX: 0,
            offsetY: 0
          },
          resizeDrag: {
            active: false,
            pointerId: null,
            axis: null,
            startTileX: 0,
            startTileY: 0,
            startWidth: 0,
            startHeight: 0
          },
          canvasUI: {
            widthHandle: null,
            heightHandle: null
          },
          exportTick: 0
        };

        var refs = {
          canvas: document.getElementById('studio-canvas'),
          pixelPreview: document.getElementById('pixel-preview'),
          buildingId: document.getElementById('building-id'),
          buildingName: document.getElementById('building-name'),
          buildingCategory: document.getElementById('building-category'),
          buildingCost: document.getElementById('building-cost'),
          buildingMaxCount: document.getElementById('building-max-count'),
          mapSize: document.getElementById('map-size'),
          footprintWidth: document.getElementById('footprint-width'),
          footprintHeight: document.getElementById('footprint-height'),
          footprintStat: document.getElementById('footprint-stat'),
          placeX: document.getElementById('place-x'),
          placeY: document.getElementById('place-y'),
          placeCenter: document.getElementById('place-center'),
          groundPlaneEnabled: document.getElementById('ground-plane-enabled'),
          groundPlaneColor: document.getElementById('ground-plane-color'),
          levelButtons: document.getElementById('level-buttons'),
          levelAdd: document.getElementById('level-add'),
          levelRemove: document.getElementById('level-remove'),
          levelClone: document.getElementById('level-clone'),
          levelUp: document.getElementById('level-up'),
          levelDown: document.getElementById('level-down'),
          currentLevel: document.getElementById('current-level'),
          upgradeCost: document.getElementById('upgrade-cost'),
          simGold: document.getElementById('sim-gold'),
          simAddGold: document.getElementById('sim-add-gold'),
          levelStat: document.getElementById('level-stat'),
          frameUpload: document.getElementById('frame-upload'),
          spritesheetCanvas: document.getElementById('spritesheet-canvas'),
          spritesheetInfo: document.getElementById('spritesheet-info'),
          spritesheetUpload: document.getElementById('spritesheet-upload'),
          spritesheetFrameWidth: document.getElementById('spritesheet-frame-width'),
          spritesheetFrameHeight: document.getElementById('spritesheet-frame-height'),
          spritesheetStartX: document.getElementById('spritesheet-start-x'),
          spritesheetStartY: document.getElementById('spritesheet-start-y'),
          spritesheetSpacingX: document.getElementById('spritesheet-spacing-x'),
          spritesheetSpacingY: document.getElementById('spritesheet-spacing-y'),
          spritesheetCols: document.getElementById('spritesheet-cols'),
          spritesheetRows: document.getElementById('spritesheet-rows'),
          spritesheetMaxFrames: document.getElementById('spritesheet-max-frames'),
          spritesheetSlice: document.getElementById('spritesheet-slice'),
          spritesheetResetView: document.getElementById('spritesheet-reset-view'),
          animPlay: document.getElementById('anim-play'),
          animStop: document.getElementById('anim-stop'),
          animReset: document.getElementById('anim-reset'),
          frameClear: document.getElementById('frame-clear'),
          frameDefaultMs: document.getElementById('frame-default-ms'),
          frameApplyDefault: document.getElementById('frame-apply-default'),
          animLoop: document.getElementById('anim-loop'),
          animStat: document.getElementById('anim-stat'),
          frameList: document.getElementById('frame-list'),
          assetLabel: document.getElementById('asset-label'),
          imageOffsetX: document.getElementById('image-offset-x'),
          imageOffsetY: document.getElementById('image-offset-y'),
          imageScale: document.getElementById('image-scale'),
          imageRotation: document.getElementById('image-rotation'),
          imageOpacity: document.getElementById('image-opacity'),
          autoFit: document.getElementById('auto-fit'),
          resetImage: document.getElementById('reset-image'),
          imageInfo: document.getElementById('image-info'),
          copyJson: document.getElementById('copy-json'),
          downloadJson: document.getElementById('download-json'),
          copyTs: document.getElementById('copy-ts'),
          jsonOutput: document.getElementById('json-output'),
          tsOutput: document.getElementById('ts-output')
        };

        var offscreenScene = document.createElement('canvas');
        var offscreenPixel = document.createElement('canvas');

        function getCurrentLevelConfig() {
          for (var i = 0; i < state.levels.length; i++) {
            if (state.levels[i].level === state.currentLevel) {
              return state.levels[i];
            }
          }
          return state.levels[0];
        }

        function setCurrentLevel(level) {
          var minLevel = 1;
          var maxLevel = state.levels.length;
          state.currentLevel = clampInt(level, minLevel, maxLevel);
          refs.currentLevel.value = String(state.currentLevel);
          renderLevelButtons();
          syncLevelInputs();
          syncImageInputs();
          renderFrameList();
        }

        function renderLevelButtons() {
          refs.levelButtons.innerHTML = '';
          for (var i = 0; i < state.levels.length; i++) {
            (function () {
              var levelObj = state.levels[i];
              var btn = document.createElement('button');
              btn.type = 'button';
              btn.textContent = 'L' + levelObj.level;
              if (levelObj.level === state.currentLevel) btn.classList.add('active');
              btn.addEventListener('click', function () {
                setCurrentLevel(levelObj.level);
              });
              refs.levelButtons.appendChild(btn);
            })();
          }
        }

        function addLevel(cloneCurrent) {
          var next = state.levels.length + 1;
          var source = cloneCurrent ? getCurrentLevelConfig() : null;
          state.levels.push(makeLevel(next, source));
          setCurrentLevel(next);
        }

        function removeLastLevel() {
          if (state.levels.length <= 1) return;
          state.levels.pop();
          if (state.currentLevel > state.levels.length) {
            state.currentLevel = state.levels.length;
          }
          setCurrentLevel(state.currentLevel);
        }

        function levelUpNoCost() {
          if (state.currentLevel < state.levels.length) {
            setCurrentLevel(state.currentLevel + 1);
          }
        }

        function canUpgradeWithGold() {
          if (state.currentLevel >= state.levels.length) return false;
          var level = getCurrentLevelConfig();
          return state.simulation.gold >= Math.max(0, level.upgradeCost);
        }

        function levelUpWithGold() {
          if (state.currentLevel >= state.levels.length) {
            state.simulation.lastNotice = 'At max level.';
            return;
          }
          var level = getCurrentLevelConfig();
          var cost = Math.max(0, level.upgradeCost);
          if (state.simulation.gold < cost) {
            var need = cost - state.simulation.gold;
            state.simulation.lastNotice = 'Need ' + need + ' more gold to upgrade.';
            return;
          }

          state.simulation.gold -= cost;
          state.simulation.lastNotice = 'Upgraded to L' + (state.currentLevel + 1) + ' (-' + cost + ' gold).';
          setCurrentLevel(state.currentLevel + 1);
        }

        function levelDown() {
          if (state.currentLevel > 1) {
            setCurrentLevel(state.currentLevel - 1);
          }
        }

        function footprintCenterIso() {
          var cx = state.placement.x + state.building.width * 0.5;
          var cy = state.placement.y + state.building.height * 0.5;
          return cartToIso(cx, cy);
        }

        function syncLevelInputs() {
          var level = getCurrentLevelConfig();
          refs.upgradeCost.value = String(level.upgradeCost);
          refs.simGold.value = String(state.simulation.gold);
          var canUpgrade = canUpgradeWithGold();
          refs.levelStat.textContent =
            'Current level: ' + state.currentLevel + ' / ' + state.levels.length +
            ' | Upgrade cost: ' + level.upgradeCost +
            ' | Gold: ' + state.simulation.gold +
            ' | Can upgrade: ' + (canUpgrade ? 'yes' : 'no') +
            (state.simulation.lastNotice ? ' | ' + state.simulation.lastNotice : '');
        }

        function syncImageInputs() {
          var level = getCurrentLevelConfig();
          refs.imageOffsetX.value = String(Math.round(level.transform.offsetX));
          refs.imageOffsetY.value = String(Math.round(level.transform.offsetY));
          refs.imageScale.value = String(level.transform.scale);
          refs.imageRotation.value = String(level.transform.rotation);
          refs.imageOpacity.value = String(level.transform.opacity);

          if (level.frames.length === 0) {
            refs.imageInfo.textContent = 'No frames loaded for Level ' + level.level + '.';
          } else {
            var frame = level.frames[level.frameIndex] || level.frames[0];
            refs.imageInfo.textContent =
              'L' + level.level + ': ' + level.frames.length + ' frame(s), current frame ' + (level.frameIndex + 1) +
              ' (' + frame.label + ', ' + frame.width + 'x' + frame.height + ')';
          }
        }

        function updateFootprintStat() {
          refs.footprintStat.textContent =
            'Footprint: ' + state.building.width + 'x' + state.building.height +
            ' | Area: ' + (state.building.width * state.building.height) + ' tiles';
        }

        function clampPlacement() {
          var maxX = Math.max(0, state.mapSize - state.building.width);
          var maxY = Math.max(0, state.mapSize - state.building.height);
          state.placement.x = clampInt(state.placement.x, 0, maxX);
          state.placement.y = clampInt(state.placement.y, 0, maxY);
          refs.placeX.value = String(state.placement.x);
          refs.placeY.value = String(state.placement.y);
        }

        function applyFootprintSize(nextW, nextH) {
          state.building.width = clampInt(nextW, 1, 10);
          state.building.height = clampInt(nextH, 1, 10);
          refs.footprintWidth.value = String(state.building.width);
          refs.footprintHeight.value = String(state.building.height);
          updateFootprintStat();
          clampPlacement();
        }

        function adjustFootprint(deltaW, deltaH) {
          applyFootprintSize(state.building.width + deltaW, state.building.height + deltaH);
        }

        function resizeCanvas(canvas) {
          var rect = canvas.getBoundingClientRect();
          var dpr = window.devicePixelRatio || 1;
          var width = Math.max(1, Math.floor(rect.width));
          var height = Math.max(1, Math.floor(rect.height));
          var targetW = Math.max(1, Math.floor(width * dpr));
          var targetH = Math.max(1, Math.floor(height * dpr));
          if (canvas.width !== targetW || canvas.height !== targetH) {
            canvas.width = targetW;
            canvas.height = targetH;
          }
          return { width: width, height: height, dpr: dpr };
        }

        function getSheetSettingsFromInputs() {
          return {
            frameWidth: Math.max(1, Math.floor(Number(refs.spritesheetFrameWidth.value) || 1)),
            frameHeight: Math.max(1, Math.floor(Number(refs.spritesheetFrameHeight.value) || 1)),
            startX: Math.max(0, Math.floor(Number(refs.spritesheetStartX.value) || 0)),
            startY: Math.max(0, Math.floor(Number(refs.spritesheetStartY.value) || 0)),
            spacingX: Math.max(0, Math.floor(Number(refs.spritesheetSpacingX.value) || 0)),
            spacingY: Math.max(0, Math.floor(Number(refs.spritesheetSpacingY.value) || 0)),
            cols: Math.max(0, Math.floor(Number(refs.spritesheetCols.value) || 0)),
            rows: Math.max(0, Math.floor(Number(refs.spritesheetRows.value) || 0)),
            maxFrames: Math.max(0, Math.floor(Number(refs.spritesheetMaxFrames.value) || 0))
          };
        }

        function setSheetSelection(startX, startY, frameW, frameH) {
          refs.spritesheetStartX.value = String(Math.max(0, Math.floor(startX)));
          refs.spritesheetStartY.value = String(Math.max(0, Math.floor(startY)));
          refs.spritesheetFrameWidth.value = String(Math.max(1, Math.floor(frameW)));
          refs.spritesheetFrameHeight.value = String(Math.max(1, Math.floor(frameH)));
        }

        function clampSheetSettingsToImage() {
          if (!state.sheetEditor.image) return;
          var settings = getSheetSettingsFromInputs();
          var iw = state.sheetEditor.width;
          var ih = state.sheetEditor.height;

          settings.startX = clampInt(settings.startX, 0, Math.max(0, iw - 1));
          settings.startY = clampInt(settings.startY, 0, Math.max(0, ih - 1));
          settings.frameWidth = clampInt(settings.frameWidth, 1, Math.max(1, iw - settings.startX));
          settings.frameHeight = clampInt(settings.frameHeight, 1, Math.max(1, ih - settings.startY));

          refs.spritesheetStartX.value = String(settings.startX);
          refs.spritesheetStartY.value = String(settings.startY);
          refs.spritesheetFrameWidth.value = String(settings.frameWidth);
          refs.spritesheetFrameHeight.value = String(settings.frameHeight);
        }

        function computeSheetGridMeta(settings) {
          var iw = state.sheetEditor.width;
          var ih = state.sheetEditor.height;
          var stepX = Math.max(1, settings.frameWidth + settings.spacingX);
          var stepY = Math.max(1, settings.frameHeight + settings.spacingY);
          var availW = Math.max(0, iw - settings.startX);
          var availH = Math.max(0, ih - settings.startY);
          var autoCols = Math.max(0, Math.floor((availW + settings.spacingX) / stepX));
          var autoRows = Math.max(0, Math.floor((availH + settings.spacingY) / stepY));
          var cols = settings.cols > 0 ? settings.cols : autoCols;
          var rows = settings.rows > 0 ? settings.rows : autoRows;
          cols = Math.max(0, cols);
          rows = Math.max(0, rows);

          var total = cols * rows;
          if (settings.maxFrames > 0) total = Math.min(total, settings.maxFrames);
          return {
            cols: cols,
            rows: rows,
            stepX: stepX,
            stepY: stepY,
            frameCount: total
          };
        }

        function toSheetCanvasPoint(event) {
          var rect = refs.spritesheetCanvas.getBoundingClientRect();
          return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top,
            width: rect.width,
            height: rect.height
          };
        }

        function imageToSheetScreen(ix, iy) {
          return {
            x: ix * state.sheetEditor.viewScale + state.sheetEditor.viewOffsetX,
            y: iy * state.sheetEditor.viewScale + state.sheetEditor.viewOffsetY
          };
        }

        function sheetScreenToImage(sx, sy) {
          return {
            x: (sx - state.sheetEditor.viewOffsetX) / state.sheetEditor.viewScale,
            y: (sy - state.sheetEditor.viewOffsetY) / state.sheetEditor.viewScale
          };
        }

        function resetSpriteSheetView() {
          if (!state.sheetEditor.image) return;
          var m = resizeCanvas(refs.spritesheetCanvas);
          var fitScale = Math.min(m.width / state.sheetEditor.width, m.height / state.sheetEditor.height);
          fitScale = clamp(fitScale * 0.95, 0.05, 20);
          state.sheetEditor.viewScale = fitScale;
          state.sheetEditor.viewOffsetX = (m.width - state.sheetEditor.width * fitScale) * 0.5;
          state.sheetEditor.viewOffsetY = (m.height - state.sheetEditor.height * fitScale) * 0.5;
        }

        function setSpriteSheetInEditor(info) {
          state.sheetEditor.image = info.image;
          state.sheetEditor.fileName = info.name || 'sprite_sheet';
          state.sheetEditor.width = info.width;
          state.sheetEditor.height = info.height;

          // Intelligent defaults: keep existing frame size if plausible, otherwise use full image.
          var fw = Math.max(1, Math.floor(Number(refs.spritesheetFrameWidth.value) || 1));
          var fh = Math.max(1, Math.floor(Number(refs.spritesheetFrameHeight.value) || 1));
          if (fw > info.width) fw = info.width;
          if (fh > info.height) fh = info.height;
          setSheetSelection(0, 0, fw, fh);

          resetSpriteSheetView();
          clampSheetSettingsToImage();
          renderSpriteSheetEditor();
        }

        function renderSpriteSheetEditor() {
          var m = resizeCanvas(refs.spritesheetCanvas);
          var ctx = refs.spritesheetCanvas.getContext('2d');
          ctx.setTransform(m.dpr, 0, 0, m.dpr, 0, 0);
          ctx.clearRect(0, 0, m.width, m.height);

          if (!state.sheetEditor.image) {
            refs.spritesheetInfo.textContent = 'Load a sprite sheet, then drag on the preview to set frame bounds.';
            ctx.fillStyle = 'rgba(210,222,245,0.82)';
            ctx.font = '12px sans-serif';
            ctx.fillText('No sprite sheet loaded', 12, 20);
            return;
          }

          var settings = getSheetSettingsFromInputs();
          clampSheetSettingsToImage();
          settings = getSheetSettingsFromInputs();
          var meta = computeSheetGridMeta(settings);

          var drawX = state.sheetEditor.viewOffsetX;
          var drawY = state.sheetEditor.viewOffsetY;
          var drawW = state.sheetEditor.width * state.sheetEditor.viewScale;
          var drawH = state.sheetEditor.height * state.sheetEditor.viewScale;

          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(state.sheetEditor.image, drawX, drawY, drawW, drawH);

          // Sheet bounds
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(180, 201, 236, 0.92)';
          ctx.strokeRect(drawX, drawY, drawW, drawH);

          // Grid overlays
          var maxCells = Math.min(meta.frameCount, 500);
          for (var i = 0; i < maxCells; i++) {
            var col = i % Math.max(1, meta.cols);
            var row = Math.floor(i / Math.max(1, meta.cols));
            if (row >= meta.rows) break;
            var gx = settings.startX + col * meta.stepX;
            var gy = settings.startY + row * meta.stepY;
            var p = imageToSheetScreen(gx, gy);
            var gw = settings.frameWidth * state.sheetEditor.viewScale;
            var gh = settings.frameHeight * state.sheetEditor.viewScale;
            ctx.strokeStyle = 'rgba(80, 190, 255, 0.42)';
            ctx.strokeRect(p.x, p.y, gw, gh);
          }

          // Active frame rectangle
          var sel = imageToSheetScreen(settings.startX, settings.startY);
          var selW = settings.frameWidth * state.sheetEditor.viewScale;
          var selH = settings.frameHeight * state.sheetEditor.viewScale;
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(255, 196, 64, 0.95)';
          ctx.strokeRect(sel.x, sel.y, selW, selH);

          var handleSize = 9;
          var hx = sel.x + selW;
          var hy = sel.y + selH;
          ctx.fillStyle = 'rgba(255,196,64,0.95)';
          ctx.fillRect(hx - handleSize * 0.5, hy - handleSize * 0.5, handleSize, handleSize);
          ctx.strokeStyle = 'rgba(17,22,35,0.9)';
          ctx.lineWidth = 1;
          ctx.strokeRect(hx - handleSize * 0.5, hy - handleSize * 0.5, handleSize, handleSize);

          refs.spritesheetInfo.textContent =
            state.sheetEditor.fileName +
            ' | Sheet: ' + state.sheetEditor.width + 'x' + state.sheetEditor.height +
            ' | Slice: x=' + settings.startX + ', y=' + settings.startY +
            ', w=' + settings.frameWidth + ', h=' + settings.frameHeight +
            ' | Frames: ' + meta.frameCount;
        }

        function getSheetSelectionScreenRect() {
          if (!state.sheetEditor.image) return null;
          var settings = getSheetSettingsFromInputs();
          var p = imageToSheetScreen(settings.startX, settings.startY);
          return {
            x: p.x,
            y: p.y,
            w: settings.frameWidth * state.sheetEditor.viewScale,
            h: settings.frameHeight * state.sheetEditor.viewScale
          };
        }

        function getView(width, height) {
          return {
            originX: width * 0.5,
            originY: Math.max(90, height * 0.17)
          };
        }

        function toCanvasPoint(event) {
          var rect = refs.canvas.getBoundingClientRect();
          return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top,
            width: rect.width,
            height: rect.height
          };
        }

        function pointToTile(px, py, canvasWidth, canvasHeight) {
          var view = getView(canvasWidth, canvasHeight);
          var cart = isoToCart(px - view.originX, py - view.originY);
          return {
            x: Math.floor(cart.x),
            y: Math.floor(cart.y)
          };
        }

        function currentFrame() {
          var level = getCurrentLevelConfig();
          if (level.frames.length === 0) return null;
          if (level.frameIndex < 0 || level.frameIndex >= level.frames.length) {
            level.frameIndex = 0;
          }
          return level.frames[level.frameIndex];
        }

        function isTileInsideFootprint(tx, ty) {
          return (
            tx >= state.placement.x &&
            ty >= state.placement.y &&
            tx < state.placement.x + state.building.width &&
            ty < state.placement.y + state.building.height
          );
        }

        function isPointOnCurrentImage(px, py, canvasWidth, canvasHeight) {
          var frame = currentFrame();
          if (!frame) return false;

          var level = getCurrentLevelConfig();
          var view = getView(canvasWidth, canvasHeight);
          var center = footprintCenterIso();

          var anchorX = view.originX + center.x + level.transform.offsetX;
          var anchorY = view.originY + center.y + level.transform.offsetY;

          var dx = px - anchorX;
          var dy = py - anchorY;

          var rad = (-level.transform.rotation * Math.PI) / 180;
          var cos = Math.cos(rad);
          var sin = Math.sin(rad);

          var localX = dx * cos - dy * sin;
          var localY = dx * sin + dy * cos;

          var drawW = frame.width * level.transform.scale;
          var drawH = frame.height * level.transform.scale;

          // bottom-center anchor
          return localX >= -drawW * 0.5 && localX <= drawW * 0.5 && localY >= -drawH && localY <= 0;
        }

        function drawTile(ctx, originX, originY, tx, ty) {
          var pos = cartToIso(tx, ty);

          // Matches MainScene.drawIsoTile palette + variation logic.
          var baseColors = [0x4a9c3d, 0x52a844, 0x48943a, 0x5bb34d, 0x4fa041];
          var colorIndex = (tx * 7 + ty * 13) % baseColors.length;
          var baseColor = baseColors[colorIndex];

          var tileColor = (tx + ty) % 2 === 0
            ? brightenHex(baseColor, 5)
            : darkenHex(baseColor, 3);

          var pTop = { x: originX + pos.x, y: originY + pos.y };
          var pRight = { x: originX + pos.x + HALF_W, y: originY + pos.y + HALF_H };
          var pBottom = { x: originX + pos.x, y: originY + pos.y + TILE_H };
          var pLeft = { x: originX + pos.x - HALF_W, y: originY + pos.y + HALF_H };

          ctx.beginPath();
          ctx.moveTo(pTop.x, pTop.y);
          ctx.lineTo(pRight.x, pRight.y);
          ctx.lineTo(pBottom.x, pBottom.y);
          ctx.lineTo(pLeft.x, pLeft.y);
          ctx.closePath();
          ctx.fillStyle = rgbToStyle(tileColor, 1);
          ctx.fill();

          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.beginPath();
          ctx.moveTo(pLeft.x, pLeft.y);
          ctx.lineTo(pTop.x, pTop.y);
          ctx.lineTo(pRight.x, pRight.y);
          ctx.stroke();

          ctx.strokeStyle = 'rgba(0,0,0,0.12)';
          ctx.beginPath();
          ctx.moveTo(pRight.x, pRight.y);
          ctx.lineTo(pBottom.x, pBottom.y);
          ctx.lineTo(pLeft.x, pLeft.y);
          ctx.stroke();

          if ((tx * 3 + ty * 5) % 7 === 0) {
            var detail = darkenHex(baseColor, 15);
            ctx.fillStyle = rgbToStyle(detail, 0.4);
            ctx.beginPath();
            ctx.arc(
              originX + pos.x + Math.sin(tx * ty) * 5,
              originY + pos.y + HALF_H + Math.cos(tx * ty) * 3,
              2,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
        }

        function drawFootprint(ctx, originX, originY) {
          var w = state.building.width;
          var h = state.building.height;

          // Tile outlines
          ctx.lineWidth = 1.5;
          ctx.strokeStyle = 'rgba(41,100,255,0.45)';
          for (var x = state.placement.x; x < state.placement.x + w; x++) {
            for (var y = state.placement.y; y < state.placement.y + h; y++) {
              var pos = cartToIso(x, y);
              ctx.beginPath();
              ctx.moveTo(originX + pos.x, originY + pos.y);
              ctx.lineTo(originX + pos.x + HALF_W, originY + pos.y + HALF_H);
              ctx.lineTo(originX + pos.x, originY + pos.y + TILE_H);
              ctx.lineTo(originX + pos.x - HALF_W, originY + pos.y + HALF_H);
              ctx.closePath();
              ctx.stroke();
            }
          }

          // Outer border only
          var top = cartToIso(state.placement.x, state.placement.y);
          var right = cartToIso(state.placement.x + w, state.placement.y);
          var bottom = cartToIso(state.placement.x + w, state.placement.y + h);
          var left = cartToIso(state.placement.x, state.placement.y + h);

          ctx.lineWidth = 3;
          ctx.strokeStyle = 'rgba(32,84,255,0.95)';
          ctx.beginPath();
          ctx.moveTo(originX + top.x, originY + top.y);
          ctx.lineTo(originX + right.x, originY + right.y);
          ctx.lineTo(originX + bottom.x, originY + bottom.y);
          ctx.lineTo(originX + left.x, originY + left.y);
          ctx.closePath();
          ctx.stroke();

          // Edge drag handles for resize.
          var rightMid = {
            x: originX + (right.x + bottom.x) * 0.5,
            y: originY + (right.y + bottom.y) * 0.5
          };
          var bottomMid = {
            x: originX + (left.x + bottom.x) * 0.5,
            y: originY + (left.y + bottom.y) * 0.5
          };

          function drawHandle(x, y, active) {
            var radius = 11;
            ctx.fillStyle = active ? 'rgba(32,84,255,1)' : 'rgba(41,100,255,0.95)';
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(236,243,255,0.95)';
            ctx.stroke();
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x, y, 2.2, 0, Math.PI * 2);
            ctx.fill();
            return { x: x, y: y, r: radius };
          }

          state.canvasUI.widthHandle = drawHandle(
            rightMid.x + 22,
            rightMid.y,
            state.resizeDrag.active && state.resizeDrag.axis === 'width'
          );
          state.canvasUI.heightHandle = drawHandle(
            bottomMid.x,
            bottomMid.y + 22,
            state.resizeDrag.active && state.resizeDrag.axis === 'height'
          );
        }

        function drawBuildingGroundPlane(ctx, originX, originY) {
          if (!state.building.groundPlaneEnabled) return;

          var top = cartToIso(state.placement.x, state.placement.y);
          var right = cartToIso(state.placement.x + state.building.width, state.placement.y);
          var bottom = cartToIso(state.placement.x + state.building.width, state.placement.y + state.building.height);
          var left = cartToIso(state.placement.x, state.placement.y + state.building.height);

          ctx.fillStyle = hexToRgba(state.building.groundPlaneColor, 0.28);
          ctx.beginPath();
          ctx.moveTo(originX + top.x, originY + top.y);
          ctx.lineTo(originX + right.x, originY + right.y);
          ctx.lineTo(originX + bottom.x, originY + bottom.y);
          ctx.lineTo(originX + left.x, originY + left.y);
          ctx.closePath();
          ctx.fill();

          ctx.lineWidth = 1;
          ctx.strokeStyle = hexToRgba(state.building.groundPlaneColor, 0.7);
          ctx.stroke();
        }

        function drawImageAtAnchor(ctx, frame, level, anchorX, anchorY, includeOffset) {
          if (!frame || !level) return;
          var offX = includeOffset ? level.transform.offsetX : 0;
          var offY = includeOffset ? level.transform.offsetY : 0;

          var x = anchorX + offX;
          var y = anchorY + offY;

          var dw = frame.width * level.transform.scale;
          var dh = frame.height * level.transform.scale;

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate((level.transform.rotation * Math.PI) / 180);
          ctx.globalAlpha = clamp(level.transform.opacity, 0.05, 1);
          ctx.imageSmoothingEnabled = true;
          // bottom-center anchor so it sits on footprint center.
          ctx.drawImage(frame.image, -dw * 0.5, -dh, dw, dh);
          ctx.restore();
        }

        function drawCurrentImage(ctx, originX, originY) {
          var frame = currentFrame();
          if (!frame) return;
          var level = getCurrentLevelConfig();
          var center = footprintCenterIso();
          drawImageAtAnchor(ctx, frame, level, originX + center.x, originY + center.y, true);
        }

        function drawFloatingPreviewIsland(ctx, width) {
          var frame = currentFrame();
          var level = getCurrentLevelConfig();
          var fw = state.building.width;
          var fh = state.building.height;
          var fullSpan = Math.max(1, (fw + fh) * HALF_W);
          var previewScale = Math.min(1, 240 / fullSpan);

          var localCenter = cartToIso(fw * 0.5, fh * 0.5);
          var localTop = cartToIso(0, 0);
          var localRight = cartToIso(fw, 0);
          var localBottom = cartToIso(fw, fh);
          var localLeft = cartToIso(0, fh);

          var screenMargin = 20;
          var centerX = width - screenMargin - (fullSpan * 0.5 * previewScale);
          var centerY = 76;
          var originX = centerX - localCenter.x * previewScale;
          var originY = centerY - localTop.y * previewScale;

          ctx.save();
          ctx.translate(originX, originY);
          ctx.scale(previewScale, previewScale);

          // Flat ground-only plane (no external drop shadow).

          for (var x = 0; x < fw; x++) {
            for (var y = 0; y < fh; y++) {
              drawTile(ctx, 0, 0, x + 300, y + 300);
            }
          }

          ctx.save();
          ctx.beginPath();
          ctx.moveTo(localTop.x, localTop.y);
          ctx.lineTo(localRight.x, localRight.y);
          ctx.lineTo(localBottom.x, localBottom.y);
          ctx.lineTo(localLeft.x, localLeft.y);
          ctx.closePath();
          ctx.clip();

          if (state.building.groundPlaneEnabled) {
            ctx.fillStyle = hexToRgba(state.building.groundPlaneColor, 0.26);
            ctx.fillRect(localLeft.x - 8, localTop.y - 8, (localRight.x - localLeft.x) + 16, (localBottom.y - localTop.y) + 16);
          }
          ctx.restore();

          // Thin border around the floating plane.
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(39, 66, 50, 0.7)';
          ctx.beginPath();
          ctx.moveTo(localTop.x, localTop.y);
          ctx.lineTo(localRight.x, localRight.y);
          ctx.lineTo(localBottom.x, localBottom.y);
          ctx.lineTo(localLeft.x, localLeft.y);
          ctx.closePath();
          ctx.stroke();

          if (frame) {
            drawImageAtAnchor(ctx, frame, level, localCenter.x, localCenter.y, true);
          }

          ctx.restore();
        }

        function renderScene(sceneCtx, width, height) {
          var view = getView(width, height);

          sceneCtx.clearRect(0, 0, width, height);
          sceneCtx.fillStyle = '#eef4ff';
          sceneCtx.fillRect(0, 0, width, height);

          for (var x = 0; x < state.mapSize; x++) {
            for (var y = 0; y < state.mapSize; y++) {
              drawTile(sceneCtx, view.originX, view.originY, x, y);
            }
          }

          drawBuildingGroundPlane(sceneCtx, view.originX, view.originY);
          drawFootprint(sceneCtx, view.originX, view.originY);
          drawCurrentImage(sceneCtx, view.originX, view.originY);
          drawFloatingPreviewIsland(sceneCtx, width);
        }

        function renderOverlayUI(uiCtx, width) {
          void uiCtx;
          void width;
        }

        function presentToCanvas() {
          var m = resizeCanvas(refs.canvas);
          var sceneW = Math.max(1, Math.floor(m.width * m.dpr));
          var sceneH = Math.max(1, Math.floor(m.height * m.dpr));
          if (offscreenScene.width !== sceneW || offscreenScene.height !== sceneH) {
            offscreenScene.width = sceneW;
            offscreenScene.height = sceneH;
          }

          var sceneCtx = offscreenScene.getContext('2d');
          sceneCtx.setTransform(m.dpr, 0, 0, m.dpr, 0, 0);
          renderScene(sceneCtx, m.width, m.height);

          var displayCtx = refs.canvas.getContext('2d');
          displayCtx.setTransform(1, 0, 0, 1, 0, 0);
          displayCtx.clearRect(0, 0, refs.canvas.width, refs.canvas.height);

          if (!state.pixelPreview) {
            displayCtx.imageSmoothingEnabled = true;
            displayCtx.drawImage(offscreenScene, 0, 0);
          } else {
            var smallW = Math.max(1, Math.floor(refs.canvas.width / PIXEL_SIZE_GAME_DEFAULT));
            var smallH = Math.max(1, Math.floor(refs.canvas.height / PIXEL_SIZE_GAME_DEFAULT));
            offscreenPixel.width = smallW;
            offscreenPixel.height = smallH;

            var pctx = offscreenPixel.getContext('2d');
            pctx.setTransform(1, 0, 0, 1, 0, 0);
            pctx.clearRect(0, 0, smallW, smallH);
            pctx.imageSmoothingEnabled = false;
            pctx.drawImage(offscreenScene, 0, 0, smallW, smallH);

            displayCtx.imageSmoothingEnabled = false;
            displayCtx.drawImage(offscreenPixel, 0, 0, smallW, smallH, 0, 0, refs.canvas.width, refs.canvas.height);
          }

          // Draw UI and text after pixel pass so overlays remain crisp.
          displayCtx.setTransform(m.dpr, 0, 0, m.dpr, 0, 0);
          renderOverlayUI(displayCtx, m.width);
        }

        function autoFitToFootprint() {
          var level = getCurrentLevelConfig();
          var frame = currentFrame();
          if (!frame) return;

          var footprintSpanW = (state.building.width + state.building.height) * HALF_W;
          var footprintSpanH = (state.building.width + state.building.height) * HALF_H;

          var scaleW = footprintSpanW / frame.width;
          var minVisualHeight = footprintSpanH * 2.0;
          var scaleH = minVisualHeight / frame.height;
          level.transform.scale = clamp(Math.max(scaleW, scaleH), 0.05, 20);

          var metrics = getFrameOpaqueMetrics(frame);
          var scale = level.transform.scale;
          var localOpaqueX = -frame.width * scale * 0.5 + (metrics ? metrics.lowestX : frame.width * 0.5) * scale;
          var localOpaqueY = -frame.height * scale + (metrics ? metrics.lowestY : frame.height) * scale;

          var centerIso = footprintCenterIso();
          var bottomCornerIso = cartToIso(state.placement.x + state.building.width, state.placement.y + state.building.height);

          // Auto-place by snapping lowest opaque pixel to the footprint's lowest corner.
          level.transform.offsetX = bottomCornerIso.x - centerIso.x - localOpaqueX;
          level.transform.offsetY = bottomCornerIso.y - centerIso.y - localOpaqueY;
          level.transform.rotation = 0;

          syncImageInputs();
        }

        function loadImageElementFromFile(file) {
          return new Promise(function (resolve, reject) {
            if (!file || !file.type || file.type.indexOf('image/') !== 0) {
              reject(new Error('Not an image file'));
              return;
            }

            var reader = new FileReader();
            reader.onerror = function () {
              reject(new Error('File read failed'));
            };
            reader.onload = function () {
              var src = reader.result;
              if (typeof src !== 'string') {
                reject(new Error('Invalid image source'));
                return;
              }

              var img = new Image();
              img.onload = function () {
                resolve({
                  image: img,
                  name: file.name,
                  width: img.width,
                  height: img.height
                });
              };
              img.onerror = function () {
                reject(new Error('Image decode failed'));
              };
              img.src = src;
            };
            reader.readAsDataURL(file);
          });
        }

        function makeFrameFromImageSource(sourceImage, sourceName, sx, sy, sw, sh, labelSuffix) {
          var cv = document.createElement('canvas');
          cv.width = sw;
          cv.height = sh;
          var c = cv.getContext('2d');
          c.clearRect(0, 0, sw, sh);
          c.imageSmoothingEnabled = true;
          c.drawImage(sourceImage, sx, sy, sw, sh, 0, 0, sw, sh);

          var baseName = String(sourceName || 'frame').replace(/\.[^.]+$/, '');
          var suffix = labelSuffix ? '_' + labelSuffix : '';
          return {
            id: 'fr_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 7),
            label: baseName + suffix + '.png',
            durationMs: state.animation.defaultDurationMs,
            image: cv,
            width: sw,
            height: sh
          };
        }

        async function sliceSpriteSheetIntoFrames(source, options) {
          var info = source && source.image ? source : await loadImageElementFromFile(source);
          var frameW = Math.max(1, options.frameWidth);
          var frameH = Math.max(1, options.frameHeight);
          var startX = Math.max(0, options.startX);
          var startY = Math.max(0, options.startY);
          var spacingX = Math.max(0, options.spacingX);
          var spacingY = Math.max(0, options.spacingY);

          var stepX = frameW + spacingX;
          var stepY = frameH + spacingY;
          var availW = Math.max(0, info.width - startX);
          var availH = Math.max(0, info.height - startY);

          var cols = options.cols > 0 ? options.cols : Math.floor((availW + spacingX) / stepX);
          var rows = options.rows > 0 ? options.rows : Math.floor((availH + spacingY) / stepY);
          cols = Math.max(0, cols);
          rows = Math.max(0, rows);

          var maxFrames = options.maxFrames > 0 ? options.maxFrames : Number.POSITIVE_INFINITY;
          var frames = [];
          var i = 0;

          for (var r = 0; r < rows; r++) {
            for (var c = 0; c < cols; c++) {
              if (frames.length >= maxFrames) break;
              var sx = startX + c * stepX;
              var sy = startY + r * stepY;
              if (sx + frameW > info.width || sy + frameH > info.height) continue;
              i += 1;
              frames.push(
                makeFrameFromImageSource(
                  info.image,
                  info.name,
                  sx,
                  sy,
                  frameW,
                  frameH,
                  'sheet_' + i
                )
              );
            }
            if (frames.length >= maxFrames) break;
          }

          return frames;
        }

        function loadImageFromFile(file) {
          return loadImageElementFromFile(file).then(function (info) {
            return makeFrameFromImageSource(info.image, info.name, 0, 0, info.width, info.height, '');
          });
        }

        async function addFrames(files) {
          if (!files || files.length === 0) return;
          var level = getCurrentLevelConfig();
          var arr = Array.prototype.slice.call(files);
          for (var i = 0; i < arr.length; i++) {
            try {
              var frame = await loadImageFromFile(arr[i]);
              level.frames.push(frame);
            } catch (err) {
              console.warn('Skipping frame:', err);
            }
          }

          if (level.frames.length > 0 && level.frameIndex >= level.frames.length) {
            level.frameIndex = 0;
            level.frameElapsed = 0;
          }

          if (level.frames.length > 0) {
            refs.assetLabel.value = level.frames[level.frameIndex].label;
            autoFitToFootprint();
          }

          syncImageInputs();
          renderFrameList();
        }

        function renderFrameList() {
          var level = getCurrentLevelConfig();
          refs.frameList.innerHTML = '';

          if (level.frames.length === 0) {
            var empty = document.createElement('div');
            empty.className = 'small';
            empty.textContent = 'No frames loaded.';
            refs.frameList.appendChild(empty);
            refs.animStat.textContent = 'Frames: 0';
            return;
          }

          refs.animStat.textContent =
            'Frames: ' + level.frames.length +
            ' | Current frame: ' + (level.frameIndex + 1) +
            ' | Playing: ' + (state.animation.playing ? 'yes' : 'no');

          for (var i = 0; i < level.frames.length; i++) {
            (function (frameIndex) {
              var frame = level.frames[frameIndex];
              var row = document.createElement('div');
              row.className = 'frame-row';

              var label = document.createElement('div');
              label.className = 'frame-label';
              label.textContent = (frameIndex + 1) + '. ' + frame.label;
              row.appendChild(label);

              var dur = document.createElement('input');
              dur.type = 'number';
              dur.min = '16';
              dur.value = String(frame.durationMs);
              dur.title = 'Duration ms';
              dur.addEventListener('input', function () {
                frame.durationMs = Math.max(16, Number(dur.value) || 160);
              });
              row.appendChild(dur);

              var useBtn = document.createElement('button');
              useBtn.type = 'button';
              useBtn.textContent = 'Use';
              useBtn.addEventListener('click', function () {
                level.frameIndex = frameIndex;
                level.frameElapsed = 0;
                refs.assetLabel.value = frame.label;
                syncImageInputs();
                renderFrameList();
              });
              row.appendChild(useBtn);

              var upBtn = document.createElement('button');
              upBtn.type = 'button';
              upBtn.textContent = '↑';
              upBtn.addEventListener('click', function () {
                if (frameIndex <= 0) return;
                var temp = level.frames[frameIndex - 1];
                level.frames[frameIndex - 1] = level.frames[frameIndex];
                level.frames[frameIndex] = temp;
                if (level.frameIndex === frameIndex) level.frameIndex = frameIndex - 1;
                else if (level.frameIndex === frameIndex - 1) level.frameIndex = frameIndex;
                renderFrameList();
              });
              row.appendChild(upBtn);

              var delBtn = document.createElement('button');
              delBtn.type = 'button';
              delBtn.textContent = '×';
              delBtn.addEventListener('click', function () {
                level.frames.splice(frameIndex, 1);
                if (level.frameIndex >= level.frames.length) level.frameIndex = Math.max(0, level.frames.length - 1);
                level.frameElapsed = 0;
                syncImageInputs();
                renderFrameList();
              });
              row.appendChild(delBtn);

              if (frameIndex === level.frameIndex) {
                row.style.borderColor = '#3a6bff';
                row.style.boxShadow = '0 0 0 1px rgba(58,107,255,0.25)';
              }

              refs.frameList.appendChild(row);
            })(i);
          }
        }

        function advanceAnimation(deltaMs) {
          if (!state.animation.playing) return;
          var level = getCurrentLevelConfig();
          if (level.frames.length <= 1) return;

          level.frameElapsed += deltaMs;

          while (level.frameElapsed >= level.frames[level.frameIndex].durationMs) {
            level.frameElapsed -= level.frames[level.frameIndex].durationMs;
            level.frameIndex += 1;

            if (level.frameIndex >= level.frames.length) {
              if (state.animation.loop) {
                level.frameIndex = 0;
              } else {
                level.frameIndex = level.frames.length - 1;
                state.animation.playing = false;
                break;
              }
            }
          }
        }

        function buildExportPayload() {
          var center = footprintCenterIso();
          return {
            tool: 'Clash Local Building Studio',
            tileConfig: {
              tileWidth: TILE_W,
              tileHeight: TILE_H,
              pixelPreview: {
                enabled: state.pixelPreview,
                fixedSize: PIXEL_SIZE_GAME_DEFAULT
              },
              grassMatch: 'MainScene.drawIsoTile palette/variation/highlight/shadow/detail'
            },
            building: {
              id: state.building.id,
              name: state.building.name,
              category: state.building.category,
              cost: Math.max(0, state.building.cost),
              maxCount: Math.max(1, state.building.maxCount),
              width: state.building.width,
              height: state.building.height,
              groundPlaneEnabled: state.building.groundPlaneEnabled,
              groundPlaneColor: state.building.groundPlaneColor,
              placement: {
                gridX: state.placement.x,
                gridY: state.placement.y,
                centerIso: center
              }
            },
            levels: state.levels.map(function (lv) {
              return {
                level: lv.level,
                upgradeCost: lv.upgradeCost,
                transform: {
                  offsetX: lv.transform.offsetX,
                  offsetY: lv.transform.offsetY,
                  scale: lv.transform.scale,
                  rotationDeg: lv.transform.rotation,
                  opacity: lv.transform.opacity
                },
                frames: lv.frames.map(function (f) {
                  return {
                    label: f.label,
                    width: f.width,
                    height: f.height,
                    durationMs: f.durationMs
                  };
                })
              };
            }),
            animation: {
              loop: state.animation.loop,
              defaultDurationMs: state.animation.defaultDurationMs
            },
            simulation: {
              gold: state.simulation.gold
            },
            preview: {
              currentLevel: state.currentLevel
            }
          };
        }

        function buildTsSnippet(payload) {
          var base = payload.building.id.toUpperCase().replace(/[^A-Z0-9_]/g, '_') || 'CUSTOM_BUILDING';
          return [
            payload.building.id + ': {',
            "  id: '" + payload.building.id + "',",
            "  name: '" + payload.building.name.replace(/'/g, "\\'") + "',",
            '  cost: ' + payload.building.cost + ',',
            "  desc: 'Custom animated image building',",
            '  width: ' + payload.building.width + ',',
            '  height: ' + payload.building.height + ',',
            '  maxHealth: 1000,',
            "  category: '" + payload.building.category + "',",
            '  maxCount: ' + payload.building.maxCount + ',',
            '  maxLevel: ' + payload.levels.length,
            '}',
            '',
            'const ' + base + '_LEVEL_ART = ' + JSON.stringify(payload.levels, null, 2) + ';',
            'const ' + base + '_ANIMATION = ' + JSON.stringify(payload.animation, null, 2) + ';',
            'const ' + base + '_PLACEMENT = ' + JSON.stringify(payload.building.placement, null, 2) + ';'
          ].join('\n');
        }

        function updateExportOutputs() {
          var payload = buildExportPayload();
          refs.jsonOutput.value = JSON.stringify(payload, null, 2);
          refs.tsOutput.value = buildTsSnippet(payload);
        }

        function copyText(text) {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).catch(function () {
              window.alert('Copy failed. Copy manually from text box.');
            });
            return;
          }
          window.prompt('Copy text:', text);
        }

        function downloadText(filename, text) {
          var blob = new Blob([text], { type: 'application/json;charset=utf-8' });
          var url = URL.createObjectURL(blob);
          var a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        function hitCircle(px, py, circle) {
          if (!circle) return false;
          var dx = px - circle.x;
          var dy = py - circle.y;
          return dx * dx + dy * dy <= circle.r * circle.r;
        }

        function beginImageDrag(pointer, point) {
          var level = getCurrentLevelConfig();
          var view = getView(point.width, point.height);
          var center = footprintCenterIso();
          var anchorX = view.originX + center.x + level.transform.offsetX;
          var anchorY = view.originY + center.y + level.transform.offsetY;

          state.imageDrag.active = true;
          state.imageDrag.pointerId = pointer.pointerId;
          state.imageDrag.offsetX = point.x - anchorX;
          state.imageDrag.offsetY = point.y - anchorY;
          refs.canvas.setPointerCapture(pointer.pointerId);
        }

        function beginPlacementDrag(pointer, tile) {
          state.placement.dragActive = true;
          state.placement.pointerId = pointer.pointerId;
          state.placement.dragStartTileX = tile.x;
          state.placement.dragStartTileY = tile.y;
          state.placement.startPlacementX = state.placement.x;
          state.placement.startPlacementY = state.placement.y;
          refs.canvas.setPointerCapture(pointer.pointerId);
        }

        function beginResizeDrag(pointer, tile, axis) {
          state.resizeDrag.active = true;
          state.resizeDrag.pointerId = pointer.pointerId;
          state.resizeDrag.axis = axis;
          state.resizeDrag.startTileX = tile.x;
          state.resizeDrag.startTileY = tile.y;
          state.resizeDrag.startWidth = state.building.width;
          state.resizeDrag.startHeight = state.building.height;
          refs.canvas.setPointerCapture(pointer.pointerId);
        }

        function stopDrag(pointerId) {
          if (state.imageDrag.active && state.imageDrag.pointerId === pointerId) {
            state.imageDrag.active = false;
            state.imageDrag.pointerId = null;
          }
          if (state.placement.dragActive && state.placement.pointerId === pointerId) {
            state.placement.dragActive = false;
            state.placement.pointerId = null;
          }
          if (state.resizeDrag.active && state.resizeDrag.pointerId === pointerId) {
            state.resizeDrag.active = false;
            state.resizeDrag.pointerId = null;
            state.resizeDrag.axis = null;
          }
          if (refs.canvas.hasPointerCapture(pointerId)) {
            refs.canvas.releasePointerCapture(pointerId);
          }
        }

        refs.canvas.addEventListener('pointerdown', function (event) {
          var p = toCanvasPoint(event);
          var tile = pointToTile(p.x, p.y, p.width, p.height);

          if (hitCircle(p.x, p.y, state.canvasUI.widthHandle)) {
            beginResizeDrag(event, tile, 'width');
            return;
          }
          if (hitCircle(p.x, p.y, state.canvasUI.heightHandle)) {
            beginResizeDrag(event, tile, 'height');
            return;
          }

          if (isPointOnCurrentImage(p.x, p.y, p.width, p.height)) {
            beginImageDrag(event, p);
            return;
          }

          if (tile.x < 0 || tile.y < 0 || tile.x >= state.mapSize || tile.y >= state.mapSize) return;

          if (isTileInsideFootprint(tile.x, tile.y)) {
            beginPlacementDrag(event, tile);
            return;
          }

          state.placement.x = tile.x;
          state.placement.y = tile.y;
          clampPlacement();
        });

        refs.canvas.addEventListener('pointermove', function (event) {
          var p = toCanvasPoint(event);
          var tile = pointToTile(p.x, p.y, p.width, p.height);

          if (state.imageDrag.active && state.imageDrag.pointerId === event.pointerId) {
            var level = getCurrentLevelConfig();
            var view = getView(p.width, p.height);
            var center = footprintCenterIso();
            level.transform.offsetX = p.x - (view.originX + center.x) - state.imageDrag.offsetX;
            level.transform.offsetY = p.y - (view.originY + center.y) - state.imageDrag.offsetY;
            syncImageInputs();
            return;
          }

          if (state.resizeDrag.active && state.resizeDrag.pointerId === event.pointerId) {
            if (state.resizeDrag.axis === 'width') {
              applyFootprintSize(
                state.resizeDrag.startWidth + (tile.x - state.resizeDrag.startTileX),
                state.resizeDrag.startHeight
              );
            } else if (state.resizeDrag.axis === 'height') {
              applyFootprintSize(
                state.resizeDrag.startWidth,
                state.resizeDrag.startHeight + (tile.y - state.resizeDrag.startTileY)
              );
            }
            return;
          }

          if (state.placement.dragActive && state.placement.pointerId === event.pointerId) {
            var dx = tile.x - state.placement.dragStartTileX;
            var dy = tile.y - state.placement.dragStartTileY;
            state.placement.x = state.placement.startPlacementX + dx;
            state.placement.y = state.placement.startPlacementY + dy;
            clampPlacement();
          }
        });

        refs.canvas.addEventListener('pointerup', function (event) {
          stopDrag(event.pointerId);
        });

        refs.canvas.addEventListener('pointercancel', function (event) {
          stopDrag(event.pointerId);
        });

        refs.canvas.addEventListener('dragover', function (event) {
          event.preventDefault();
        });

        refs.canvas.addEventListener('drop', function (event) {
          event.preventDefault();
          if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length) {
            addFrames(event.dataTransfer.files);
          }
        });

        refs.canvas.addEventListener('wheel', function (event) {
          var p = toCanvasPoint(event);
          if (!isPointOnCurrentImage(p.x, p.y, p.width, p.height)) return;
          event.preventDefault();
          var level = getCurrentLevelConfig();
          level.transform.scale = clamp(level.transform.scale + (event.deltaY < 0 ? 0.06 : -0.06), 0.05, 20);
          syncImageInputs();
        }, { passive: false });

        function stopSheetEditorDrag(pointerId) {
          if (!state.sheetEditor.dragActive) return;
          if (state.sheetEditor.dragPointerId !== pointerId) return;
          state.sheetEditor.dragActive = false;
          state.sheetEditor.dragPointerId = null;
          state.sheetEditor.dragMode = null;
          if (refs.spritesheetCanvas.hasPointerCapture(pointerId)) {
            refs.spritesheetCanvas.releasePointerCapture(pointerId);
          }
        }

        refs.spritesheetCanvas.addEventListener('pointerdown', function (event) {
          if (!state.sheetEditor.image) return;
          var p = toSheetCanvasPoint(event);
          var rect = getSheetSelectionScreenRect();
          if (!rect) return;

          var handleX = rect.x + rect.w;
          var handleY = rect.y + rect.h;
          var dxh = p.x - handleX;
          var dyh = p.y - handleY;
          var inHandle = dxh * dxh + dyh * dyh <= 12 * 12;
          var inRect = p.x >= rect.x && p.x <= rect.x + rect.w && p.y >= rect.y && p.y <= rect.y + rect.h;

          state.sheetEditor.dragActive = true;
          state.sheetEditor.dragPointerId = event.pointerId;
          state.sheetEditor.dragMode = inHandle ? 'resize-frame' : (inRect ? 'move-frame' : 'pan-view');
          state.sheetEditor.dragStartScreenX = p.x;
          state.sheetEditor.dragStartScreenY = p.y;
          state.sheetEditor.dragStartViewOffsetX = state.sheetEditor.viewOffsetX;
          state.sheetEditor.dragStartViewOffsetY = state.sheetEditor.viewOffsetY;

          var settings = getSheetSettingsFromInputs();
          state.sheetEditor.dragStartFrameX = settings.startX;
          state.sheetEditor.dragStartFrameY = settings.startY;
          state.sheetEditor.dragStartFrameW = settings.frameWidth;
          state.sheetEditor.dragStartFrameH = settings.frameHeight;

          refs.spritesheetCanvas.setPointerCapture(event.pointerId);
        });

        refs.spritesheetCanvas.addEventListener('pointermove', function (event) {
          if (!state.sheetEditor.dragActive || state.sheetEditor.dragPointerId !== event.pointerId) return;
          if (!state.sheetEditor.image) return;

          var p = toSheetCanvasPoint(event);
          var dxScreen = p.x - state.sheetEditor.dragStartScreenX;
          var dyScreen = p.y - state.sheetEditor.dragStartScreenY;
          var scale = Math.max(0.0001, state.sheetEditor.viewScale);

          if (state.sheetEditor.dragMode === 'pan-view') {
            state.sheetEditor.viewOffsetX = state.sheetEditor.dragStartViewOffsetX + dxScreen;
            state.sheetEditor.viewOffsetY = state.sheetEditor.dragStartViewOffsetY + dyScreen;
          } else if (state.sheetEditor.dragMode === 'move-frame') {
            setSheetSelection(
              state.sheetEditor.dragStartFrameX + dxScreen / scale,
              state.sheetEditor.dragStartFrameY + dyScreen / scale,
              state.sheetEditor.dragStartFrameW,
              state.sheetEditor.dragStartFrameH
            );
            clampSheetSettingsToImage();
          } else if (state.sheetEditor.dragMode === 'resize-frame') {
            setSheetSelection(
              state.sheetEditor.dragStartFrameX,
              state.sheetEditor.dragStartFrameY,
              state.sheetEditor.dragStartFrameW + dxScreen / scale,
              state.sheetEditor.dragStartFrameH + dyScreen / scale
            );
            clampSheetSettingsToImage();
          }

          renderSpriteSheetEditor();
        });

        refs.spritesheetCanvas.addEventListener('pointerup', function (event) {
          stopSheetEditorDrag(event.pointerId);
        });

        refs.spritesheetCanvas.addEventListener('pointercancel', function (event) {
          stopSheetEditorDrag(event.pointerId);
        });

        refs.spritesheetCanvas.addEventListener('wheel', function (event) {
          if (!state.sheetEditor.image) return;
          event.preventDefault();
          var p = toSheetCanvasPoint(event);
          var before = sheetScreenToImage(p.x, p.y);
          var nextScale = state.sheetEditor.viewScale * (event.deltaY < 0 ? 1.1 : 0.9);
          state.sheetEditor.viewScale = clamp(nextScale, 0.05, 20);
          state.sheetEditor.viewOffsetX = p.x - before.x * state.sheetEditor.viewScale;
          state.sheetEditor.viewOffsetY = p.y - before.y * state.sheetEditor.viewScale;
          renderSpriteSheetEditor();
        }, { passive: false });

        refs.spritesheetCanvas.addEventListener('dblclick', function () {
          resetSpriteSheetView();
          renderSpriteSheetEditor();
        });

        refs.spritesheetResetView.addEventListener('click', function () {
          resetSpriteSheetView();
          renderSpriteSheetEditor();
        });

        refs.spritesheetUpload.addEventListener('change', async function () {
          var file = refs.spritesheetUpload.files && refs.spritesheetUpload.files[0];
          if (!file) return;
          try {
            var info = await loadImageElementFromFile(file);
            setSpriteSheetInEditor(info);
          } catch (err) {
            console.error(err);
            refs.spritesheetInfo.textContent = 'Failed to load sprite sheet.';
          }
        });

        [
          refs.spritesheetFrameWidth,
          refs.spritesheetFrameHeight,
          refs.spritesheetStartX,
          refs.spritesheetStartY,
          refs.spritesheetSpacingX,
          refs.spritesheetSpacingY,
          refs.spritesheetCols,
          refs.spritesheetRows,
          refs.spritesheetMaxFrames
        ].forEach(function (el) {
          el.addEventListener('input', function () {
            var min = (el === refs.spritesheetFrameWidth || el === refs.spritesheetFrameHeight) ? 1 : 0;
            var value = Math.max(min, Math.floor(Number(el.value) || 0));
            el.value = String(value);
            clampSheetSettingsToImage();
            renderSpriteSheetEditor();
          });
        });

        refs.pixelPreview.addEventListener('change', function () {
          state.pixelPreview = !!refs.pixelPreview.checked;
        });

        refs.buildingId.addEventListener('input', function () {
          state.building.id = refs.buildingId.value.trim();
        });

        refs.buildingName.addEventListener('input', function () {
          state.building.name = refs.buildingName.value;
        });

        refs.buildingCategory.addEventListener('change', function () {
          state.building.category = refs.buildingCategory.value;
        });

        refs.buildingCost.addEventListener('input', function () {
          state.building.cost = Number(refs.buildingCost.value) || 0;
        });

        refs.buildingMaxCount.addEventListener('input', function () {
          state.building.maxCount = Math.max(1, Number(refs.buildingMaxCount.value) || 1);
        });

        refs.mapSize.addEventListener('input', function () {
          state.mapSize = clampInt(Number(refs.mapSize.value) || 25, 8, 64);
          refs.mapSize.value = String(state.mapSize);
          clampPlacement();
        });

        refs.footprintWidth.addEventListener('input', function () {
          state.building.width = clampInt(Number(refs.footprintWidth.value) || 1, 1, 10);
          refs.footprintWidth.value = String(state.building.width);
          updateFootprintStat();
          clampPlacement();
        });

        refs.footprintHeight.addEventListener('input', function () {
          state.building.height = clampInt(Number(refs.footprintHeight.value) || 1, 1, 10);
          refs.footprintHeight.value = String(state.building.height);
          updateFootprintStat();
          clampPlacement();
        });

        refs.placeX.addEventListener('input', function () {
          state.placement.x = Number(refs.placeX.value) || 0;
          clampPlacement();
        });

        refs.placeY.addEventListener('input', function () {
          state.placement.y = Number(refs.placeY.value) || 0;
          clampPlacement();
        });

        refs.placeCenter.addEventListener('click', function () {
          state.placement.x = Math.floor((state.mapSize - state.building.width) * 0.5);
          state.placement.y = Math.floor((state.mapSize - state.building.height) * 0.5);
          clampPlacement();
        });

        refs.groundPlaneEnabled.addEventListener('change', function () {
          state.building.groundPlaneEnabled = !!refs.groundPlaneEnabled.checked;
          refs.groundPlaneColor.disabled = !state.building.groundPlaneEnabled;
        });

        refs.groundPlaneColor.addEventListener('input', function () {
          var value = refs.groundPlaneColor.value || '#4a9c3d';
          state.building.groundPlaneColor = value;
          if (!state.building.groundPlaneEnabled) {
            state.building.groundPlaneEnabled = true;
            refs.groundPlaneEnabled.checked = true;
          }
          refs.groundPlaneColor.disabled = !state.building.groundPlaneEnabled;
        });

        refs.levelAdd.addEventListener('click', function () {
          addLevel(false);
        });

        refs.levelClone.addEventListener('click', function () {
          addLevel(true);
        });

        refs.levelRemove.addEventListener('click', function () {
          removeLastLevel();
        });

        refs.levelUp.addEventListener('click', function () {
          levelUpWithGold();
        });

        refs.levelDown.addEventListener('click', function () {
          levelDown();
        });

        refs.currentLevel.addEventListener('input', function () {
          setCurrentLevel(Number(refs.currentLevel.value) || 1);
        });

        refs.upgradeCost.addEventListener('input', function () {
          var lv = getCurrentLevelConfig();
          lv.upgradeCost = Math.max(0, Number(refs.upgradeCost.value) || 0);
          syncLevelInputs();
        });

        refs.simGold.addEventListener('input', function () {
          state.simulation.gold = Math.max(0, Math.floor(Number(refs.simGold.value) || 0));
          refs.simGold.value = String(state.simulation.gold);
          syncLevelInputs();
        });

        refs.simAddGold.addEventListener('click', function () {
          state.simulation.gold += 5000;
          syncLevelInputs();
        });

        refs.frameUpload.addEventListener('change', function () {
          if (refs.frameUpload.files && refs.frameUpload.files.length) {
            addFrames(refs.frameUpload.files);
            refs.frameUpload.value = '';
          }
        });

        refs.spritesheetSlice.addEventListener('click', async function () {
          var file = refs.spritesheetUpload.files && refs.spritesheetUpload.files[0];
          if (!file && !state.sheetEditor.image) {
            window.alert('Select a sprite sheet image first.');
            return;
          }

          clampSheetSettingsToImage();
          var settings = getSheetSettingsFromInputs();
          if (settings.frameWidth <= 0 || settings.frameHeight <= 0) {
            window.alert('Frame width and height must be greater than 0.');
            return;
          }

          var options = {
            frameWidth: settings.frameWidth,
            frameHeight: settings.frameHeight,
            startX: settings.startX,
            startY: settings.startY,
            spacingX: settings.spacingX,
            spacingY: settings.spacingY,
            cols: settings.cols,
            rows: settings.rows,
            maxFrames: settings.maxFrames
          };

          var sourceInfo = state.sheetEditor.image
            ? {
              image: state.sheetEditor.image,
              name: state.sheetEditor.fileName || (file ? file.name : 'sprite_sheet'),
              width: state.sheetEditor.width,
              height: state.sheetEditor.height
            }
            : null;

          if (sourceInfo) {
            var predicted = computeSheetGridMeta(settings).frameCount;
            if (predicted > 80) {
              var ok = window.confirm('This slice will create about ' + predicted + ' frames. Continue?');
              if (!ok) return;
            }
          }

          try {
            var lv = getCurrentLevelConfig();

            // Sprite-sheet slicing always replaces the current animation set.
            lv.frames = [];
            lv.frameIndex = 0;
            lv.frameElapsed = 0;

            var sliced = await sliceSpriteSheetIntoFrames(sourceInfo || file, options);
            if (sliced.length === 0) {
              window.alert('No frames were sliced. Check frame size/spacing/rows/cols.');
              renderFrameList();
              syncImageInputs();
              return;
            }

            Array.prototype.push.apply(lv.frames, sliced);
            lv.frameIndex = 0;
            lv.frameElapsed = 0;

            refs.assetLabel.value = lv.frames[lv.frameIndex].label;
            autoFitToFootprint();
            syncImageInputs();
            renderFrameList();
          } catch (err) {
            console.error(err);
            window.alert('Sprite sheet import failed.');
          }
        });

        refs.animPlay.addEventListener('click', function () {
          state.animation.playing = true;
          state.animation.lastTs = 0;
          renderFrameList();
        });

        refs.animStop.addEventListener('click', function () {
          state.animation.playing = false;
          renderFrameList();
        });

        refs.animReset.addEventListener('click', function () {
          var lv = getCurrentLevelConfig();
          lv.frameIndex = 0;
          lv.frameElapsed = 0;
          renderFrameList();
          syncImageInputs();
        });

        refs.frameClear.addEventListener('click', function () {
          var lv = getCurrentLevelConfig();
          lv.frames = [];
          lv.frameIndex = 0;
          lv.frameElapsed = 0;
          renderFrameList();
          syncImageInputs();
        });

        refs.animLoop.addEventListener('change', function () {
          state.animation.loop = !!refs.animLoop.checked;
          renderFrameList();
        });

        refs.frameDefaultMs.addEventListener('input', function () {
          state.animation.defaultDurationMs = Math.max(16, Math.floor(Number(refs.frameDefaultMs.value) || 160));
          refs.frameDefaultMs.value = String(state.animation.defaultDurationMs);
        });

        refs.frameApplyDefault.addEventListener('click', function () {
          var lv = getCurrentLevelConfig();
          for (var i = 0; i < lv.frames.length; i++) {
            lv.frames[i].durationMs = state.animation.defaultDurationMs;
          }
          renderFrameList();
        });

        refs.assetLabel.addEventListener('input', function () {
          var lv = getCurrentLevelConfig();
          var frame = currentFrame();
          if (frame) {
            frame.label = refs.assetLabel.value;
            renderFrameList();
          }
        });

        refs.imageOffsetX.addEventListener('input', function () {
          var lv = getCurrentLevelConfig();
          lv.transform.offsetX = Number(refs.imageOffsetX.value) || 0;
        });

        refs.imageOffsetY.addEventListener('input', function () {
          var lv = getCurrentLevelConfig();
          lv.transform.offsetY = Number(refs.imageOffsetY.value) || 0;
        });

        refs.imageScale.addEventListener('input', function () {
          var lv = getCurrentLevelConfig();
          lv.transform.scale = clamp(Number(refs.imageScale.value) || 1, 0.05, 20);
          refs.imageScale.value = String(lv.transform.scale);
        });

        refs.imageRotation.addEventListener('input', function () {
          var lv = getCurrentLevelConfig();
          lv.transform.rotation = Number(refs.imageRotation.value) || 0;
        });

        refs.imageOpacity.addEventListener('input', function () {
          var lv = getCurrentLevelConfig();
          lv.transform.opacity = clamp(Number(refs.imageOpacity.value) || 1, 0.05, 1);
          refs.imageOpacity.value = String(lv.transform.opacity);
        });

        refs.autoFit.addEventListener('click', function () {
          autoFitToFootprint();
        });

        refs.resetImage.addEventListener('click', function () {
          var lv = getCurrentLevelConfig();
          lv.transform.offsetX = 0;
          lv.transform.offsetY = 0;
          lv.transform.scale = 1;
          lv.transform.rotation = 0;
          lv.transform.opacity = 1;
          syncImageInputs();
        });

        refs.copyJson.addEventListener('click', function () {
          copyText(refs.jsonOutput.value);
        });

        refs.downloadJson.addEventListener('click', function () {
          var id = state.building.id || 'custom_building';
          downloadText(id + '.local-building-studio.json', refs.jsonOutput.value);
        });

        refs.copyTs.addEventListener('click', function () {
          copyText(refs.tsOutput.value);
        });

        function frameLoop(ts) {
          if (!state.animation.lastTs) state.animation.lastTs = ts;
          var delta = ts - state.animation.lastTs;
          state.animation.lastTs = ts;

          advanceAnimation(delta);
          presentToCanvas();
          renderSpriteSheetEditor();

          if (ts - state.exportTick > 220) {
            updateExportOutputs();
            state.exportTick = ts;
          }

          requestAnimationFrame(frameLoop);
        }

        function init() {
          refs.pixelPreview.checked = state.pixelPreview;
          refs.animLoop.checked = state.animation.loop;
          refs.frameDefaultMs.value = String(state.animation.defaultDurationMs);
          refs.groundPlaneEnabled.checked = state.building.groundPlaneEnabled;
          refs.groundPlaneColor.value = state.building.groundPlaneColor;
          refs.groundPlaneColor.disabled = !state.building.groundPlaneEnabled;
          updateFootprintStat();
          clampPlacement();
          renderLevelButtons();
          syncLevelInputs();
          renderFrameList();
          syncImageInputs();
          renderSpriteSheetEditor();
          updateExportOutputs();
          requestAnimationFrame(frameLoop);
        }

        init();
      })();
    </script>
  </body>
</html>
